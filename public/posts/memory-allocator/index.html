<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Write a Memory Allocator for PyTorch | Zhiyang Shen&#39;s Blog</title>
<meta name="keywords" content="code, memory, system, algorithm, machine learning">
<meta name="description" content="Write a memory allocator from scratch.">
<meta name="author" content="Zhiyang Shen">
<link rel="canonical" href="http://localhost:1313/posts/memory-allocator/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9514d8875d000a50e6844112d7bdaaa71869d5b712f00bfe452405bd2e6514fd.css" integrity="sha256-lRTYh10AClDmhEES172qpxhp1bcS8Av&#43;RSQFvS5lFP0=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/memory-allocator/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Zhiyang Shen&#39;s Blog (Alt + H)">Zhiyang Shen&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/shenzhiy21" title="Github">
                    <span>Github</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Write a Memory Allocator for PyTorch
    </h1>
    <div class="post-meta"><span title='2024-05-16 15:21:52 +0800 CST'>May 16, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Zhiyang Shen

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#interface--first-approach" aria-label="Interface &amp; First Approach">Interface &amp; First Approach</a></li>
                <li>
                    <a href="#second-approach" aria-label="Second Approach">Second Approach</a></li>
                <li>
                    <a href="#third-approach-buddy-algorithm" aria-label="Third Approach: Buddy Algorithm">Third Approach: Buddy Algorithm</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>PyTorch docs 中描述了 <a href="https://pytorch.org/docs/stable/notes/cuda.html#cuda-memory-management">cuda memory management</a>, 其中简单提到了 cuda 的内存分配方法，以及 PyTorch 提供的一些用于观察内存分配情况的方法，可见 <a href="https://pytorch.org/docs/stable/torch_cuda_memory.html#torch-cuda-memory">torch cuda memory</a>. 此外，PyTorch 允许<a href="https://pytorch.org/docs/stable/notes/cuda.html#using-custom-memory-allocators-for-cuda">用户为 cuda 自定义内存分配器 (memory allocator)</a>, 只需提供特定的接口即可。当然，Memory Allocator 不仅在 GPU 资源分配中至关重要，也在操作系统等其它领域不可或缺。接下来我们将动手为 cuda 实现一个内存分配器。</p>
<h2 id="interface--first-approach">Interface &amp; First Approach<a hidden class="anchor" aria-hidden="true" href="#interface--first-approach">#</a></h2>
<p>按照 PyTorch docs 的说法，我们需要用 C/C++ 实现如下两个接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cuda_runtime_api.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">// Compile with g++ alloc.cc -o alloc.so -I/usr/local/cuda/include -shared -fPIC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">my_malloc</span>(ssize_t size, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>   cudaMalloc(<span style="color:#f92672">&amp;</span>ptr, size);
</span></span><span style="display:flex;"><span>   std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;alloc &#34;</span><span style="color:#f92672">&lt;&lt;</span>ptr<span style="color:#f92672">&lt;&lt;</span>size<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_free</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr, ssize_t size, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>   std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;free &#34;</span><span style="color:#f92672">&lt;&lt;</span>ptr<span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>stream<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>   cudaFree(ptr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后把这两个接口 export 到 Python 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> torch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Load the allocator</span>
</span></span><span style="display:flex;"><span>new_alloc <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>memory<span style="color:#f92672">.</span>CUDAPluggableAllocator(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;alloc.so&#39;</span>, <span style="color:#e6db74">&#39;my_malloc&#39;</span>, <span style="color:#e6db74">&#39;my_free&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Swap the current allocator</span>
</span></span><span style="display:flex;"><span>torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>memory<span style="color:#f92672">.</span>change_current_allocator(new_alloc)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This will allocate memory in the device using the new allocator</span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>zeros(<span style="color:#ae81ff">10</span>, device<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cuda&#39;</span>)
</span></span></code></pre></div><p>以上是一个 naive 的实现方案。在 <code>my_alloc()</code> 函数中，我们调用 <code>cuda_runtime_api.h</code> 中的 <code>cudaMalloc()</code> 函数来进行 cuda 内存分配，并在 <code>my_free()</code> 函数中调用 <code>cudaFree()</code> 函数进行内存释放。</p>
<p><code>cudaMalloc()</code> 接收两个参数，它直接分配字节数为 <code>size</code> 的内存，并将首地址赋值给 <code>ptr</code> 指针，作为 <code>my_alloc()</code> 函数的返回值（暂时不用管 <code>device</code> 和 <code>stream</code> 两个参数）。如果 <code>cudaMalloc()</code> 调用失败，或者说 cuda 无法分配这段内存了，那么该函数会返回一个非零值（遵循 POSIX 规范）。<code>my_free()</code> 函数则接收一个指针 <code>ptr</code> 与字节数 <code>size</code>, 作用是释放从 <code>ptr</code> 开始、字节数为 <code>size</code> 的这段内存。</p>
<p>我们自然会问：这个方法有什么不好的吗？事实上，频繁调用 <code>cudaMalloc()</code> 函数会占用大量时间（类似于 C/C++ 中频繁调用 <code>malloc()</code> 一样），我们应当尽量减小 cuda 内核的调用。改进方案是：我们一次性向 cuda 申请较大的内存、置入一个“内存池”中，每当 PyTorch 需要调用 <code>my_alloc()</code> 时，就直接返回内存池中一段空闲内存的首地址。而在 PyTorch 调用 <code>my_free()</code> 时，则不直接调用 <code>cudaFree()</code>, 而是 &ldquo;lazily&rdquo; 把这段内存重新放回内存池中维护起来，以供之后重新分配。</p>
<h2 id="second-approach">Second Approach<a hidden class="anchor" aria-hidden="true" href="#second-approach">#</a></h2>
<p>我们实现上述算法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cuda_runtime.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>size_t, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">*&gt;&gt;</span> free_buffers;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">managed_alloc</span>(ssize_t byteSize, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>byteSize)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;allocate request: byteSize = %lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)byteSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  byteSize <span style="color:#f92672">=</span> ((byteSize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">|</span> <span style="color:#ae81ff">1023</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// allocate memory from free_buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> it <span style="color:#f92672">=</span> free_buffers[byteSize];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (it.size()) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> it.back();
</span></span><span style="display:flex;"><span>    it.pop_back();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> size_t buffer_capacity <span style="color:#f92672">=</span> <span style="color:#ae81ff">5LLU</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> __vma_buffer_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> __vma_offset <span style="color:#f92672">=</span> buffer_capacity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  assert(byteSize <span style="color:#f92672">&lt;=</span> buffer_capacity); <span style="color:#75715e">// the byteSize request should be smaller than a single buffer_capacity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// allocate memory slice from 5GB memory buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (__vma_offset <span style="color:#f92672">+</span> byteSize <span style="color:#f92672">&lt;=</span> buffer_capacity) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>result <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)__vma_buffer_addr) <span style="color:#f92672">+</span> __vma_offset;
</span></span><span style="display:flex;"><span>    __vma_offset <span style="color:#f92672">+=</span> byteSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// allocate another new 5GB memory buffer from device memory (slow)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> memory_buffer_allocated_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;create a new 5GB memory buffer (%d had been allocated before)..</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, memory_buffer_allocated_count<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cudaMalloc(<span style="color:#f92672">&amp;</span>__vma_buffer_addr, buffer_capacity) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    fprintf(stderr, <span style="color:#e6db74">&#34;Runtime Error: CUDA could not allocate sufficient memory to complete the call.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>), fflush(stdout), fflush(stderr), _exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  __vma_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> managed_alloc(byteSize, device, stream);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">managed_free</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr, ssize_t byteSize, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;free request: size = %lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, (<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)byteSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  byteSize <span style="color:#f92672">=</span> ((byteSize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">|</span> <span style="color:#ae81ff">1023</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// cudaFree() is slow, so just save memory block in free_buffers dict
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  free_buffers[byteSize].push_back(ptr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这段代码中，我们维护了一个 <code>free_buffers</code>, 它是从 <code>size_t</code> 到 <code>vector&lt;void *&gt;</code> 的一个映射，<code>size_t</code> 参数代表内存池的片段长度，<code>vector&lt;void *&gt;</code> 参数则维护了该长度的内存池的所有空闲的指针。<code>managed_free()</code> 的最后一句 <code>free_buffers[byteSize].push_back(ptr);</code> 会把需要释放的内存首地址存进对应长度的内存池中。算法还有一个细节是，对每个输入的字节长度 <code>byteSize</code>, 我们都把它处理为 <code>1024</code> 的倍数，这样在不浪费太多资源的情况下、尽量减小了 <code>free_buffers</code> 的 <code>key</code> 的集合大小。</p>
<h2 id="third-approach-buddy-algorithm">Third Approach: Buddy Algorithm<a hidden class="anchor" aria-hidden="true" href="#third-approach-buddy-algorithm">#</a></h2>
<p>然而，上述算法仍然有缺点：内存的“碎片化”现象比较严重。假设内存池中有一段长度为 <code>2048</code> 的空闲，就只能被分配给一个长度 <code>2048</code> 的内存申请——换句话说，假设此时申请一段长度 <code>1024</code> 的内存，就无法把这段 <code>2048</code> 的片段一分为二、并把前一段 <code>1024</code> 的长度分配给调用者。因此，直觉上看，我们需要支持一个更复杂的数据结构，使得可以把内存池中的一个片段进一步“分割”成若干的小片段，类似地，在 <code>my_free()</code> 中也可以检查是否有连续的若干小片段可以“合并”成一个较大的、完整的片段。这就引出了 <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">Buddy Algorithm</a>.</p>
<p>Donald Knuth 的著作 &ldquo;The Art of Computer Programming&rdquo; 中详细提到了 buddy algorithm, 而 Linux kernel 也使用了改进的 buddy algorithm 来管理其内存分配。</p>
<p>在 buddy algorithm 中，内存池的大小、以及可分配的内存大小均为 power of two. 整个内存池为一棵二叉树的形式，根节点为最大的内存片段，每个节点均可 split 成两个孩子节点，分别代表父节点的这段内存的前后两小段（每个孩子维护的内存均为父亲的一半）。</p>
<p>在 <code>cudaMalloc()</code> 时，假设输入的 <code>byteSize</code> 已经转换到 power of 2, 那就检查内存树中长度为 <code>byteSize</code> 的节点是否有空闲：如果有空闲，则直接分配这一段；否则找到一段更大的空闲内存，并将其不断 split 直到 <code>byteSize</code> 的长度并分配。如果找不到更大的空闲内存，则抛出异常。</p>
<p>在 <code>cudaFree()</code> 时，我们把由 <code>ptr</code> 和 <code>byteSize</code> 决定的那个节点的状态置为空闲。此时检查它的 sibling（或者说 buddy, 即“伙伴”）是否同样为空闲状态，如果是，那么将它们合并 (merge), 也就是把它们的父节点的状态置为空闲。</p>
<p>以下是对 buddy algorithm 的（未经优化的）实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAX_CAPACITY (4LLU * 1024 * 1024 * 1024)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MIN_CAPACITY (1LLU * 1024)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">node_type</span> {
</span></span><span style="display:flex;"><span>  FREE,     <span style="color:#75715e">// free buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OCCUPIED, <span style="color:#75715e">// already allocated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SPLIT,    <span style="color:#75715e">// already split into two buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  NONEXIST  <span style="color:#75715e">// non-exist buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemoryAllocator</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  MemoryAllocator(size_t _capacity, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> _addr<span style="color:#f92672">=</span><span style="color:#66d9ef">nullptr</span>) <span style="color:#f92672">:</span> addr(_addr) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Memory Allocator initializing...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    capacity <span style="color:#f92672">=</span> next_power_of_two(_capacity);
</span></span><span style="display:flex;"><span>    assert(capacity <span style="color:#f92672">&gt;=</span> MIN_CAPACITY <span style="color:#f92672">&amp;&amp;</span> capacity <span style="color:#f92672">&lt;=</span> MAX_CAPACITY);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;capacity = %lu, MIN_CAPACITY = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, capacity, MIN_CAPACITY);
</span></span><span style="display:flex;"><span>    buffer_len <span style="color:#f92672">=</span> (capacity <span style="color:#f92672">/</span> MIN_CAPACITY) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    assert(buffer_len <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;buffer_len = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, buffer_len);
</span></span><span style="display:flex;"><span>    buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">uint8_t</span>[buffer_len];
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>fill(buffer, buffer <span style="color:#f92672">+</span> buffer_len, node_type<span style="color:#f92672">::</span>NONEXIST);
</span></span><span style="display:flex;"><span>    buffer[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>FREE;
</span></span><span style="display:flex;"><span>    free_buffers[capacity].insert(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Memory Allocator initialized. Capacity = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, capacity);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">~</span>MemoryAllocator() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> buffer;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set_addr</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> _addr) {
</span></span><span style="display:flex;"><span>    addr <span style="color:#f92672">=</span> _addr;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">managed_alloc</span>(ssize_t byte_size_, <span style="color:#66d9ef">bool</span><span style="color:#f92672">&amp;</span> rc) {
</span></span><span style="display:flex;"><span>    rc <span style="color:#f92672">=</span> false; <span style="color:#75715e">// return code. true: success; false: failure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>byte_size_) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;Error: byte size is 0</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    size_t byte_size <span style="color:#f92672">=</span> get_corrected_byte_size(byte_size_);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// printf(&#34;Corrected Byte Size: %lu\n&#34;, byte_size);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (byte_size <span style="color:#f92672">&gt;</span> capacity) {
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;Error: byte size exceeds capacity. byte_size = %lu, capacity = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, byte_size, capacity);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> it <span style="color:#f92672">=</span> free_buffers[byte_size];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (it.size()) {
</span></span><span style="display:flex;"><span>      size_t id <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>it.begin();
</span></span><span style="display:flex;"><span>      it.erase(it.begin());
</span></span><span style="display:flex;"><span>      buffer[id] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>OCCUPIED;
</span></span><span style="display:flex;"><span>      rc <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)addr <span style="color:#f92672">+</span> get_offset(id));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// find the smallest buffer that can be split into two buffers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> can_split <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    size_t buffer_size <span style="color:#f92672">=</span> byte_size <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (buffer_size <span style="color:#f92672">&lt;=</span> capacity) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (free_buffers[buffer_size].size()) {
</span></span><span style="display:flex;"><span>        can_split <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      buffer_size <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// printf(&#34;Can split. Buffer size = %lu\n&#34;, buffer_size);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>can_split) {
</span></span><span style="display:flex;"><span>      rc <span style="color:#f92672">=</span> false; <span style="color:#75715e">// cannot allocate memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      printf(<span style="color:#e6db74">&#34;Error: cannot allocate memory = %lu byte</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, byte_size_);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// split the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (buffer_size <span style="color:#f92672">&gt;</span> byte_size) {
</span></span><span style="display:flex;"><span>      size_t id <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>free_buffers[buffer_size].begin();
</span></span><span style="display:flex;"><span>      split(id);
</span></span><span style="display:flex;"><span>      buffer_size <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    assert(free_buffers[byte_size].size());
</span></span><span style="display:flex;"><span>    size_t id <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>free_buffers[byte_size].begin();
</span></span><span style="display:flex;"><span>    free_buffers[byte_size].erase(id);
</span></span><span style="display:flex;"><span>    buffer[id] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>OCCUPIED;
</span></span><span style="display:flex;"><span>    rc <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Allocated buffer size = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, byte_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)addr <span style="color:#f92672">+</span> get_offset(id));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">managed_free</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr, ssize_t byte_size_) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    size_t byte_size <span style="color:#f92672">=</span> get_corrected_byte_size(byte_size_);
</span></span><span style="display:flex;"><span>    assert(byte_size <span style="color:#f92672">&lt;=</span> capacity);
</span></span><span style="display:flex;"><span>    size_t id <span style="color:#f92672">=</span> get_id(ptr, byte_size);
</span></span><span style="display:flex;"><span>    assert(buffer[id] <span style="color:#f92672">==</span> node_type<span style="color:#f92672">::</span>OCCUPIED);
</span></span><span style="display:flex;"><span>    buffer[id] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>FREE;
</span></span><span style="display:flex;"><span>    free_buffers[byte_size].insert(id);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// after free memory, check if we can merge the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t parent_id <span style="color:#f92672">=</span> parent(id);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>      size_t left_id <span style="color:#f92672">=</span> left_child(parent_id);
</span></span><span style="display:flex;"><span>      size_t right_id <span style="color:#f92672">=</span> right_child(parent_id);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>merge(left_id, right_id)) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (parent_id <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>      parent_id <span style="color:#f92672">=</span> parent(parent_id);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Freed buffer size = %lu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, byte_size);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>size_t, std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;&gt;</span> free_buffers;
</span></span><span style="display:flex;"><span>  size_t capacity;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> addr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> buffer;
</span></span><span style="display:flex;"><span>  size_t buffer_len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">next_power_of_two</span>(ssize_t n) {
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">get_corrected_byte_size</span>(ssize_t byte_size) {
</span></span><span style="display:flex;"><span>    size_t n <span style="color:#f92672">=</span> next_power_of_two(byte_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> MIN_CAPACITY) n <span style="color:#f92672">=</span> MIN_CAPACITY;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">left_child</span>(size_t id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">right_child</span>(size_t id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> id <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">parent</span>(size_t id) {
</span></span><span style="display:flex;"><span>    assert(id <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (id <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">get_depth</span>(size_t id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>log2(id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">inline</span> size_t <span style="color:#a6e22e">get_depth_for_buffer_size</span>(size_t buffer_size) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>log2(MAX_CAPACITY <span style="color:#f92672">/</span> buffer_size));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t <span style="color:#a6e22e">get_offset</span>(size_t id) {
</span></span><span style="display:flex;"><span>    size_t depth <span style="color:#f92672">=</span> get_depth(id);
</span></span><span style="display:flex;"><span>    size_t first_id_of_depth <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> depth) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    size_t buffer_size <span style="color:#f92672">=</span> capacity <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> depth);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (id <span style="color:#f92672">-</span> first_id_of_depth) <span style="color:#f92672">*</span> buffer_size;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t <span style="color:#a6e22e">get_id</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr, size_t byte_size) {
</span></span><span style="display:flex;"><span>    size_t offset <span style="color:#f92672">=</span> (size_t)((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr <span style="color:#f92672">-</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)addr);
</span></span><span style="display:flex;"><span>    assert(offset <span style="color:#f92672">%</span> byte_size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    size_t depth <span style="color:#f92672">=</span> get_depth_for_buffer_size(byte_size);
</span></span><span style="display:flex;"><span>    size_t first_id_of_depth <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> depth) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> first_id_of_depth <span style="color:#f92672">+</span> (size_t)(offset <span style="color:#f92672">/</span> byte_size);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  size_t <span style="color:#a6e22e">get_buffer_size</span>(size_t id) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// get_buffer_size([0]) == capacity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// get_buffer_size([1..2]) == capacity / 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// get_buffer_size([3..6]) == capacity / 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// get_buffer_size([7..14]) == capacity / 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t depth <span style="color:#f92672">=</span> get_depth(id);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> capacity <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> depth);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">split</span>(size_t id) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// printf(&#34;Try split buffer %lu, size = %lu\n&#34;, id, get_buffer_size(id));
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert(buffer[id] <span style="color:#f92672">==</span> node_type<span style="color:#f92672">::</span>FREE);
</span></span><span style="display:flex;"><span>    size_t id1 <span style="color:#f92672">=</span> left_child(id);
</span></span><span style="display:flex;"><span>    size_t id2 <span style="color:#f92672">=</span> right_child(id);
</span></span><span style="display:flex;"><span>    assert(buffer[id1] <span style="color:#f92672">==</span> node_type<span style="color:#f92672">::</span>NONEXIST <span style="color:#f92672">&amp;&amp;</span> buffer[id2] <span style="color:#f92672">==</span> node_type<span style="color:#f92672">::</span>NONEXIST);
</span></span><span style="display:flex;"><span>    buffer[id] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>SPLIT;
</span></span><span style="display:flex;"><span>    buffer[id1] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>FREE;
</span></span><span style="display:flex;"><span>    buffer[id2] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>FREE;
</span></span><span style="display:flex;"><span>    size_t parent_buffer_size <span style="color:#f92672">=</span> get_buffer_size(id);
</span></span><span style="display:flex;"><span>    size_t buffer_size <span style="color:#f92672">=</span> parent_buffer_size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    assert(buffer_size <span style="color:#f92672">&gt;=</span> MIN_CAPACITY);
</span></span><span style="display:flex;"><span>    free_buffers[parent_buffer_size].erase(id);
</span></span><span style="display:flex;"><span>    free_buffers[buffer_size].insert(id1);
</span></span><span style="display:flex;"><span>    free_buffers[buffer_size].insert(id2);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">merge</span>(size_t id1, size_t id2) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (buffer[id1] <span style="color:#f92672">!=</span> node_type<span style="color:#f92672">::</span>FREE <span style="color:#f92672">||</span> buffer[id2] <span style="color:#f92672">!=</span> node_type<span style="color:#f92672">::</span>FREE) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (parent(id1) <span style="color:#f92672">!=</span> parent(id2) <span style="color:#f92672">||</span> id1 <span style="color:#f92672">==</span> id2) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    size_t pa <span style="color:#f92672">=</span> parent(id1);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (buffer[pa] <span style="color:#f92672">!=</span> node_type<span style="color:#f92672">::</span>SPLIT) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    buffer[pa] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>FREE;
</span></span><span style="display:flex;"><span>    size_t buffer_size <span style="color:#f92672">=</span> get_buffer_size(id1);
</span></span><span style="display:flex;"><span>    free_buffers[buffer_size].erase(id1);
</span></span><span style="display:flex;"><span>    free_buffers[buffer_size].erase(id2);
</span></span><span style="display:flex;"><span>    free_buffers[buffer_size <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>].insert(pa);
</span></span><span style="display:flex;"><span>    buffer[id1] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>NONEXIST;
</span></span><span style="display:flex;"><span>    buffer[id2] <span style="color:#f92672">=</span> node_type<span style="color:#f92672">::</span>NONEXIST;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cuda_runtime.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> MemoryAllocator <span style="color:#a6e22e">allocator</span>(MAX_CAPACITY, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">managed_alloc</span>(ssize_t byte_size, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>byte_size) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> rc <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> allocated <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> __vma_buffer_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>allocated) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cudaMalloc(<span style="color:#f92672">&amp;</span>__vma_buffer_addr, MAX_CAPACITY) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      fprintf(stderr, <span style="color:#e6db74">&#34;Runtime Error: CUDA could not allocate sufficient memory to complete the call.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>), fflush(stdout), fflush(stderr), _exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    allocated <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    allocator.set_addr(__vma_buffer_addr);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> ptr <span style="color:#f92672">=</span> allocator.managed_alloc(byte_size, rc);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>rc) {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;Fatal error: cannot allocate memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">managed_free</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr, ssize_t byte_size, <span style="color:#66d9ef">int</span> device, cudaStream_t stream) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  allocator.managed_free(ptr, byte_size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>值得注意的是，内存树并不需要显式地用树的数据结构来实现，而是可以借鉴二叉堆的实现思路，用数组来模拟。</p>
<p>然而，根据 Wikipedia 上的描述，这个算法仍然有碎片化的问题：例如，当我们申请 <code>66K</code> 的内存时，buddy algorithm 会直接分配 <code>128K</code> 的内存，这就导致了 <code>62K</code> 的浪费。可以使用 <a href="https://en.wikipedia.org/wiki/Slab_allocation">Slab allocation</a> 来解决这个问题。许多操作系统，例如 FreeBSD 和 Linux 都使用了 Slab allocation.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/code/">Code</a></li>
      <li><a href="http://localhost:1313/tags/memory/">Memory</a></li>
      <li><a href="http://localhost:1313/tags/system/">System</a></li>
      <li><a href="http://localhost:1313/tags/algorithm/">Algorithm</a></li>
      <li><a href="http://localhost:1313/tags/machine-learning/">Machine Learning</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on x"
            href="https://x.com/intent/tweet/?text=Write%20a%20Memory%20Allocator%20for%20PyTorch&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f&amp;hashtags=code%2cmemory%2csystem%2calgorithm%2cmachinelearning">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f&amp;title=Write%20a%20Memory%20Allocator%20for%20PyTorch&amp;summary=Write%20a%20Memory%20Allocator%20for%20PyTorch&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f&title=Write%20a%20Memory%20Allocator%20for%20PyTorch">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on whatsapp"
            href="https://api.whatsapp.com/send?text=Write%20a%20Memory%20Allocator%20for%20PyTorch%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on telegram"
            href="https://telegram.me/share/url?text=Write%20a%20Memory%20Allocator%20for%20PyTorch&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Write a Memory Allocator for PyTorch on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Write%20a%20Memory%20Allocator%20for%20PyTorch&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fmemory-allocator%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>@ 2024 Zhiyang Shen</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
